// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Serv.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/protocol/TCompactProtocol.h> 
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::apache::thrift::concurrency;

void construct_result_demo(const Request &req, Result &_return) {
    _return.request_id = req.request_id;
    _return.result_flag = true;
    _return.v_node_num = req.v_node_num;
    _return.v_edge_num = req.v_edge_num;
        
    NodeMap tmp_node_map;
    tmp_node_map.v_id = 1;
    tmp_node_map.p_id = 1;
    _return.node_map.push_back(tmp_node_map);
    tmp_node_map.v_id = 2;
    tmp_node_map.p_id = 2;
    _return.node_map.push_back(tmp_node_map);
    tmp_node_map.v_id = 3;
    tmp_node_map.p_id = 7;
    _return.node_map.push_back(tmp_node_map);
        
    EdgeMap tmp_edge_map;
    tmp_edge_map.v_id_1 = 1;
    tmp_edge_map.v_id_2 = 2;
    tmp_edge_map.p_id_sequence.push_back(1);
    tmp_edge_map.p_id_sequence.push_back(3);
    tmp_edge_map.p_id_sequence.push_back(2);
    _return.edge_map.push_back(tmp_edge_map);
    tmp_edge_map.p_id_sequence.clear();

    tmp_edge_map.v_id_1 = 1;
    tmp_edge_map.v_id_2 = 3;
    tmp_edge_map.p_id_sequence.push_back(1);
    tmp_edge_map.p_id_sequence.push_back(3);
    tmp_edge_map.p_id_sequence.push_back(4);
    tmp_edge_map.p_id_sequence.push_back(7);
    _return.edge_map.push_back(tmp_edge_map);
    tmp_edge_map.p_id_sequence.clear();

    tmp_edge_map.v_id_1 = 2;
    tmp_edge_map.v_id_2 = 3;
    tmp_edge_map.p_id_sequence.push_back(2);
    tmp_edge_map.p_id_sequence.push_back(3);
    tmp_edge_map.p_id_sequence.push_back(4);
    tmp_edge_map.p_id_sequence.push_back(7);
    _return.edge_map.push_back(tmp_edge_map);
    tmp_edge_map.p_id_sequence.clear();
}

class ServHandler : virtual public ServIf {
public:
    ServHandler() {
        // Your initialization goes here
    }

    void put(Result& _return, const Request& req) {
        // Your implementation goes here
        printf("req info\n");
        printf("id=%d v_node_num=%d v_edge_num=%d node_resource_dim=%d\n", 
                req.request_id, req.v_node_num, req.v_edge_num, req.node_resource_dim_num);
        printf("node info:\n");
        const std::string cpu_str = "cpu";
        const std::string memory_str = "memory";
        for (int i = 0; i < req.v_node_num; ++i) {
            printf("id:%d resource: %d %d\n", req.node[i].id, 
                    req.node[i].resource_need.find(cpu_str)->second, req.node[i].resource_need.find(memory_str)->second);
                    //req.node[i].resource_need[cpu_str], req.node[i].resource_need[memory_str]);
                    //req.node[i].resource_need["cpu"], req.node[i].resource_need["memory"]);
                    //req.node[i].resource_need[std::to_string("cpu")], req.node[i].resource_need[std::to_string("memory")]);
        }

        printf("edge info:\n");
        for (int i = 0; i < req.v_edge_num; ++i) {
            printf("from_id:%d to_id:%d bandwidth_needed:%d\n", req.edge[i].from_id, 
                    req.edge[i].to_id, req.edge[i].bandwidth_needed);
        }

        printf("map info:\n");
        int v_map_p_size = req.v_map_p.size();
        for (int i = 0; i < v_map_p_size; ++i) {
            printf("%d - %d\n", req.v_map_p[i].v_id, req.v_map_p[i].p_id);
        }


        construct_result_demo(req, _return);
    }
};

int main(int argc, char **argv) {
    int port = 9090;
    /*
    ::apache::thrift::stdcxx::shared_ptr<ServHandler> handler(new ServHandler());
    ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new ServProcessor(handler));
    ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    */

    std::shared_ptr<ServHandler> handler(new ServHandler());
    std::shared_ptr<TProcessor> processor(new ServProcessor(handler));
    std::shared_ptr<TProtocolFactory> protocolFactory(new TCompactProtocolFactory());
    std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));

    std::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(1);
    std::shared_ptr<PosixThreadFactory> threadFactory = std::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    printf("start user server...\n");

    TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);  

    server.serve();
    return 0;
}

