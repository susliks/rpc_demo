/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "scheduler_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




Node::~Node() throw() {
}


void Node::__set_id(const int32_t val) {
  this->id = val;
}

void Node::__set_resource_need(const std::map<std::string, int32_t> & val) {
  this->resource_need = val;
}
std::ostream& operator<<(std::ostream& out, const Node& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Node::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->resource_need.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              int32_t& _val6 = this->resource_need[_key5];
              xfer += iprot->readI32(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.resource_need = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Node::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Node");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource_need", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->resource_need.size()));
    std::map<std::string, int32_t> ::const_iterator _iter7;
    for (_iter7 = this->resource_need.begin(); _iter7 != this->resource_need.end(); ++_iter7)
    {
      xfer += oprot->writeString(_iter7->first);
      xfer += oprot->writeI32(_iter7->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Node &a, Node &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.resource_need, b.resource_need);
  swap(a.__isset, b.__isset);
}

Node::Node(const Node& other8) {
  id = other8.id;
  resource_need = other8.resource_need;
  __isset = other8.__isset;
}
Node& Node::operator=(const Node& other9) {
  id = other9.id;
  resource_need = other9.resource_need;
  __isset = other9.__isset;
  return *this;
}
void Node::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Node(";
  out << "id=" << to_string(id);
  out << ", " << "resource_need=" << to_string(resource_need);
  out << ")";
}


Edge::~Edge() throw() {
}


void Edge::__set_from_id(const int32_t val) {
  this->from_id = val;
}

void Edge::__set_to_id(const int32_t val) {
  this->to_id = val;
}

void Edge::__set_bandwidth_needed(const int32_t val) {
  this->bandwidth_needed = val;
}
std::ostream& operator<<(std::ostream& out, const Edge& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Edge::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->from_id);
          this->__isset.from_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->to_id);
          this->__isset.to_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bandwidth_needed);
          this->__isset.bandwidth_needed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Edge::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Edge");

  xfer += oprot->writeFieldBegin("from_id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->from_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to_id", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->to_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bandwidth_needed", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->bandwidth_needed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Edge &a, Edge &b) {
  using ::std::swap;
  swap(a.from_id, b.from_id);
  swap(a.to_id, b.to_id);
  swap(a.bandwidth_needed, b.bandwidth_needed);
  swap(a.__isset, b.__isset);
}

Edge::Edge(const Edge& other10) {
  from_id = other10.from_id;
  to_id = other10.to_id;
  bandwidth_needed = other10.bandwidth_needed;
  __isset = other10.__isset;
}
Edge& Edge::operator=(const Edge& other11) {
  from_id = other11.from_id;
  to_id = other11.to_id;
  bandwidth_needed = other11.bandwidth_needed;
  __isset = other11.__isset;
  return *this;
}
void Edge::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Edge(";
  out << "from_id=" << to_string(from_id);
  out << ", " << "to_id=" << to_string(to_id);
  out << ", " << "bandwidth_needed=" << to_string(bandwidth_needed);
  out << ")";
}


NodeMap::~NodeMap() throw() {
}


void NodeMap::__set_v_id(const int32_t val) {
  this->v_id = val;
}

void NodeMap::__set_p_id(const int32_t val) {
  this->p_id = val;
}
std::ostream& operator<<(std::ostream& out, const NodeMap& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NodeMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_id);
          this->__isset.v_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->p_id);
          this->__isset.p_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NodeMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NodeMap");

  xfer += oprot->writeFieldBegin("v_id", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->v_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p_id", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->p_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NodeMap &a, NodeMap &b) {
  using ::std::swap;
  swap(a.v_id, b.v_id);
  swap(a.p_id, b.p_id);
  swap(a.__isset, b.__isset);
}

NodeMap::NodeMap(const NodeMap& other12) {
  v_id = other12.v_id;
  p_id = other12.p_id;
  __isset = other12.__isset;
}
NodeMap& NodeMap::operator=(const NodeMap& other13) {
  v_id = other13.v_id;
  p_id = other13.p_id;
  __isset = other13.__isset;
  return *this;
}
void NodeMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NodeMap(";
  out << "v_id=" << to_string(v_id);
  out << ", " << "p_id=" << to_string(p_id);
  out << ")";
}


EdgeMap::~EdgeMap() throw() {
}


void EdgeMap::__set_v_id_1(const int32_t val) {
  this->v_id_1 = val;
}

void EdgeMap::__set_v_id_2(const int32_t val) {
  this->v_id_2 = val;
}

void EdgeMap::__set_p_id_sequence(const std::vector<int32_t> & val) {
  this->p_id_sequence = val;
}
std::ostream& operator<<(std::ostream& out, const EdgeMap& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EdgeMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_id_1);
          this->__isset.v_id_1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_id_2);
          this->__isset.v_id_2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->p_id_sequence.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->p_id_sequence.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readI32(this->p_id_sequence[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.p_id_sequence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeMap");

  xfer += oprot->writeFieldBegin("v_id_1", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->v_id_1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_id_2", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->v_id_2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p_id_sequence", ::apache::thrift::protocol::T_LIST, 23);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->p_id_sequence.size()));
    std::vector<int32_t> ::const_iterator _iter19;
    for (_iter19 = this->p_id_sequence.begin(); _iter19 != this->p_id_sequence.end(); ++_iter19)
    {
      xfer += oprot->writeI32((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EdgeMap &a, EdgeMap &b) {
  using ::std::swap;
  swap(a.v_id_1, b.v_id_1);
  swap(a.v_id_2, b.v_id_2);
  swap(a.p_id_sequence, b.p_id_sequence);
  swap(a.__isset, b.__isset);
}

EdgeMap::EdgeMap(const EdgeMap& other20) {
  v_id_1 = other20.v_id_1;
  v_id_2 = other20.v_id_2;
  p_id_sequence = other20.p_id_sequence;
  __isset = other20.__isset;
}
EdgeMap& EdgeMap::operator=(const EdgeMap& other21) {
  v_id_1 = other21.v_id_1;
  v_id_2 = other21.v_id_2;
  p_id_sequence = other21.p_id_sequence;
  __isset = other21.__isset;
  return *this;
}
void EdgeMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EdgeMap(";
  out << "v_id_1=" << to_string(v_id_1);
  out << ", " << "v_id_2=" << to_string(v_id_2);
  out << ", " << "p_id_sequence=" << to_string(p_id_sequence);
  out << ")";
}


Request::~Request() throw() {
}


void Request::__set_request_id(const int32_t val) {
  this->request_id = val;
}

void Request::__set_v_node_num(const int32_t val) {
  this->v_node_num = val;
}

void Request::__set_v_edge_num(const int32_t val) {
  this->v_edge_num = val;
}

void Request::__set_node_resource_dim_num(const int32_t val) {
  this->node_resource_dim_num = val;
}

void Request::__set_node(const std::vector<Node> & val) {
  this->node = val;
}

void Request::__set_edge(const std::vector<Edge> & val) {
  this->edge = val;
}

void Request::__set_v_map_p(const std::vector<NodeMap> & val) {
  this->v_map_p = val;
}
std::ostream& operator<<(std::ostream& out, const Request& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Request::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->request_id);
          this->__isset.request_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_node_num);
          this->__isset.v_node_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_edge_num);
          this->__isset.v_edge_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_resource_dim_num);
          this->__isset.node_resource_dim_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->node.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->node[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->edge.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->edge.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->edge[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.edge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_map_p.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->v_map_p.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->v_map_p[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_map_p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Request");

  xfer += oprot->writeFieldBegin("request_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->request_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_node_num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->v_node_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_edge_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->v_edge_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_resource_dim_num", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->node_resource_dim_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node.size()));
    std::vector<Node> ::const_iterator _iter37;
    for (_iter37 = this->node.begin(); _iter37 != this->node.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edge", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->edge.size()));
    std::vector<Edge> ::const_iterator _iter38;
    for (_iter38 = this->edge.begin(); _iter38 != this->edge.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_map_p", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_map_p.size()));
    std::vector<NodeMap> ::const_iterator _iter39;
    for (_iter39 = this->v_map_p.begin(); _iter39 != this->v_map_p.end(); ++_iter39)
    {
      xfer += (*_iter39).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Request &a, Request &b) {
  using ::std::swap;
  swap(a.request_id, b.request_id);
  swap(a.v_node_num, b.v_node_num);
  swap(a.v_edge_num, b.v_edge_num);
  swap(a.node_resource_dim_num, b.node_resource_dim_num);
  swap(a.node, b.node);
  swap(a.edge, b.edge);
  swap(a.v_map_p, b.v_map_p);
  swap(a.__isset, b.__isset);
}

Request::Request(const Request& other40) {
  request_id = other40.request_id;
  v_node_num = other40.v_node_num;
  v_edge_num = other40.v_edge_num;
  node_resource_dim_num = other40.node_resource_dim_num;
  node = other40.node;
  edge = other40.edge;
  v_map_p = other40.v_map_p;
  __isset = other40.__isset;
}
Request& Request::operator=(const Request& other41) {
  request_id = other41.request_id;
  v_node_num = other41.v_node_num;
  v_edge_num = other41.v_edge_num;
  node_resource_dim_num = other41.node_resource_dim_num;
  node = other41.node;
  edge = other41.edge;
  v_map_p = other41.v_map_p;
  __isset = other41.__isset;
  return *this;
}
void Request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Request(";
  out << "request_id=" << to_string(request_id);
  out << ", " << "v_node_num=" << to_string(v_node_num);
  out << ", " << "v_edge_num=" << to_string(v_edge_num);
  out << ", " << "node_resource_dim_num=" << to_string(node_resource_dim_num);
  out << ", " << "node=" << to_string(node);
  out << ", " << "edge=" << to_string(edge);
  out << ", " << "v_map_p=" << to_string(v_map_p);
  out << ")";
}


Result::~Result() throw() {
}


void Result::__set_request_id(const int32_t val) {
  this->request_id = val;
}

void Result::__set_result_flag(const bool val) {
  this->result_flag = val;
}

void Result::__set_v_node_num(const int32_t val) {
  this->v_node_num = val;
}

void Result::__set_v_edge_num(const int32_t val) {
  this->v_edge_num = val;
}

void Result::__set_node_map(const std::vector<NodeMap> & val) {
  this->node_map = val;
}

void Result::__set_edge_map(const std::vector<EdgeMap> & val) {
  this->edge_map = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->request_id);
          this->__isset.request_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result_flag);
          this->__isset.result_flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_node_num);
          this->__isset.v_node_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->v_edge_num);
          this->__isset.v_edge_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_map.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->node_map.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->node_map[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->edge_map.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->edge_map.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->edge_map[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.edge_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("request_id", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->request_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_flag", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->result_flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_node_num", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->v_node_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_edge_num", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->v_edge_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_map", ::apache::thrift::protocol::T_LIST, 19);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_map.size()));
    std::vector<NodeMap> ::const_iterator _iter52;
    for (_iter52 = this->node_map.begin(); _iter52 != this->node_map.end(); ++_iter52)
    {
      xfer += (*_iter52).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edge_map", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->edge_map.size()));
    std::vector<EdgeMap> ::const_iterator _iter53;
    for (_iter53 = this->edge_map.begin(); _iter53 != this->edge_map.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.request_id, b.request_id);
  swap(a.result_flag, b.result_flag);
  swap(a.v_node_num, b.v_node_num);
  swap(a.v_edge_num, b.v_edge_num);
  swap(a.node_map, b.node_map);
  swap(a.edge_map, b.edge_map);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other54) {
  request_id = other54.request_id;
  result_flag = other54.result_flag;
  v_node_num = other54.v_node_num;
  v_edge_num = other54.v_edge_num;
  node_map = other54.node_map;
  edge_map = other54.edge_map;
  __isset = other54.__isset;
}
Result& Result::operator=(const Result& other55) {
  request_id = other55.request_id;
  result_flag = other55.result_flag;
  v_node_num = other55.v_node_num;
  v_edge_num = other55.v_edge_num;
  node_map = other55.node_map;
  edge_map = other55.edge_map;
  __isset = other55.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "request_id=" << to_string(request_id);
  out << ", " << "result_flag=" << to_string(result_flag);
  out << ", " << "v_node_num=" << to_string(v_node_num);
  out << ", " << "v_edge_num=" << to_string(v_edge_num);
  out << ", " << "node_map=" << to_string(node_map);
  out << ", " << "edge_map=" << to_string(edge_map);
  out << ")";
}


